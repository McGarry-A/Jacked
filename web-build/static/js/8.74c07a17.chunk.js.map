{"version":3,"sources":["components/ExerciseDetails/ExerciseDetailsRecords.tsx","utils/Workouts/getRecords.ts"],"names":["ExerciseDetailsRecords","exerciseHistory","isLoading","Loader","VStack","space","Text","textTransform","letterSpacing","fontWeight","fontSize","my","history","oneRepMax","Object","values","map","lift","sets","flat","reduce","acc","set","weight","parseInt","reps","HStack","justifyContent","renderAchievedPR","estimatedPR","oneRepMaxArr","length","calculateOneRepMax","el","Math","max","getEstimatedOneRepMax","renderEstimatedPR","bestTotalVole","volume","renderTotalVolume","bestPerformances","bestPerformance","repsArr","Array","from","_","i","forEach","reducedSets","filter","toString","setNumber","push","getBestPerformance","textAlign","performance","index","String","renderBestPerformances"],"mappings":"sKAmHeA,UAnGgB,SAAC,GAGD,IAF7BC,EAE4B,EAF5BA,gBACAC,EAC4B,EAD5BA,UAEA,IAAKD,GAAmBC,EAAW,OAAO,cAACC,EAAA,QAAD,IA4E1C,OACE,eAACC,EAAA,QAAD,CAAQC,MAAO,EAAf,UACE,cAACC,EAAA,QAAD,CACEC,cAAe,YACfC,cAAe,KACfC,WAAY,QACZC,SAAS,KACTC,GAAI,EALN,8BA5EqB,WACvB,ICPiCC,EDO3BC,GCP2BD,EDOMX,ECN5Ba,OAAOC,OAAOH,GACxBI,KAAI,SAACC,GAAD,OAAUA,EAAKC,QACnBC,KAAK,GAEaC,QACnB,SAACC,EAAKC,GACJ,IAAKA,EAAK,OAAOD,EACjB,IAAME,EAASC,SAASF,EAAIC,QACtBE,EAAOD,SAASF,EAAIG,MAC1B,OAAIA,GAAQ,GAAKF,EAASF,EAAIE,OAAe,CAAEA,SAAQE,QAChDJ,IAET,CAAEE,OAAQ,EAAGE,KAAM,KDLnB,OACE,eAACC,EAAA,QAAD,CAAQC,eAAgB,gBAAxB,UACE,cAACrB,EAAA,QAAD,CAAMG,WAAY,IAAlB,sBACA,eAACH,EAAA,QAAD,WACGO,EAAUU,OADb,SAC2BV,EAAUY,WA+EtCG,GAzEqB,WACxB,IAAMC,EChC2B,SAACjB,GACpC,IAOMkB,EAPchB,OAAOC,OAAOH,GAASI,KAAI,SAACC,GAC9C,IAAQC,EAASD,EAATC,KAER,OAAKA,EAAKa,OACHC,kBAAmBd,GADD,CAAC,MAIKF,KAAI,SAACiB,GAAD,OAAQC,KAAKC,IAAL,MAAAD,KAAI,IAAQD,OAEzD,OAAOC,KAAKC,IAAL,MAAAD,KAAI,IAAQJ,IDsBGM,CAAsBnC,GAC1C,OACE,eAACyB,EAAA,QAAD,CAAQC,eAAgB,gBAAxB,UACE,cAACrB,EAAA,QAAD,CAAMG,WAAY,IAAlB,2BACA,eAACH,EAAA,QAAD,WAAOuB,EAAP,YAqEDQ,GAhEqB,WACxB,ICV0BzB,EDUpB0B,GCVoB1B,EDUUX,ECTzBa,OAAOC,OAAOH,GACxBI,KAAI,SAACC,GAAD,OAAUA,EAAKC,QACnBC,KAAK,GAEYC,QAAO,SAACC,EAAKC,GAC/B,IAAKA,EAAK,OAAOD,EACjB,IAEMkB,EAFSf,SAASF,EAAIC,QACfC,SAASF,EAAIG,MAE1B,OAAOc,EAASlB,EAAMkB,EAASlB,IAC9B,IDAD,OACE,eAACK,EAAA,QAAD,CAAQC,eAAgB,gBAAxB,UACE,cAACrB,EAAA,QAAD,CAAMG,WAAY,IAAlB,yBACA,eAACH,EAAA,QAAD,WAAOgC,EAAP,YA4DDE,GAvD0B,WAC7B,IAAMC,ECJwB,SAAC7B,GAQjC,IAAI8B,EAAyB,GACvBC,EAAUC,MAAMC,KAAK,CAAEd,OAAQ,KAAM,SAACe,EAAGC,GAAJ,OAAUA,EAAI,KAEnD7B,EAAOJ,OAAOC,OAAOH,GACxBI,KAAI,SAACC,GAAD,OAAUA,EAAKC,QACnBC,KAAK,GAqBR,OAnBAwB,EAAQK,SAAQ,SAACvB,EAAMsB,GACrB,IACME,EADU/B,EAAKgC,QAAO,SAAC5B,GAAD,OAASA,EAAIG,OAASA,EAAK0B,cAC3B/B,QAC1B,SAACC,EAAKC,GACJ,IAAKA,EAAK,OAAOD,EAEjB,IAAME,EAASC,SAASF,EAAIC,QACtBE,EAAOD,SAASF,EAAIG,MAE1B,OAAIF,EAASF,EAAIE,OACR,CAAEA,SAAQE,OAAM2B,UAAW9B,EAAI8B,WACjC/B,IAET,CAAEE,OAAQ,EAAGE,KAAM,EAAG2B,UAAW,IAGnCV,EAAgBW,KAAKJ,MAGhBP,ED9BoBY,CAAmBrD,GAE5C,OACE,eAACG,EAAA,QAAD,CAAQO,GAAI,EAAZ,UACE,eAACe,EAAA,QAAD,CAAQC,eAAgB,gBAAxB,UACE,cAACrB,EAAA,QAAD,CAAMiD,UAAW,SAAU9C,WAAY,IAAvC,kBAGA,cAACH,EAAA,QAAD,CAAMiD,UAAW,SAAU9C,WAAY,IAAvC,6BAGA,cAACH,EAAA,QAAD,CAAMiD,UAAW,SAAU9C,WAAY,IAAvC,oBAIF,cAACL,EAAA,QAAD,CAAQC,MAAO,EAAf,SACGoC,EAAiBzB,KAAI,SAACwC,EAAaC,GAClC,OAAyB,IAArBD,EAAY/B,MAAqC,IAAvB+B,EAAYjC,OAAqB,KAE7D,eAACG,EAAA,QAAD,CAAQC,eAAgB,gBAAxB,UACE,cAACrB,EAAA,QAAD,CAAMiD,UAAW,SAAjB,SAA6BE,GAAS,IACtC,cAACnD,EAAA,QAAD,CACEiD,UAAW,SADb,SAEKC,EAAYjC,OAFjB,SAEgCiC,EAAY/B,OAC5C,eAACnB,EAAA,QAAD,CAAMiD,UAAW,SAAjB,UACGvB,kBAAmB,CAClB,CACET,OAAQmC,OAAOF,EAAYjC,QAC3BE,KAAMiC,OAAOF,EAAY/B,SAEzB,IANN,UAL4CgC,WAoCrDE","file":"static/js/8.74c07a17.chunk.js","sourcesContent":["import { HStack, Text, VStack } from \"native-base\";\nimport { IExerciseHistory } from \"../../hooks/useExerciseHistory\";\nimport calculateOneRepMax from \"../../utils/Workouts/calculateOneRepMax\";\nimport {\n  getAcheivedOneRepMax,\n  getBestPerformance,\n  getBestVolume,\n  getEstimatedOneRepMax,\n} from \"../../utils/Workouts/getRecords\";\nimport Loader from \"../Utils/Loader\";\n\ninterface IExerciseDetailsRecods {\n  exerciseHistory: IExerciseHistory | undefined;\n  isLoading: boolean;\n}\n\nconst ExerciseDetailsRecords = ({\n  exerciseHistory,\n  isLoading,\n}: IExerciseDetailsRecods) => {\n  if (!exerciseHistory || isLoading) return <Loader />;\n\n  const renderAchievedPR = () => {\n    const oneRepMax = getAcheivedOneRepMax(exerciseHistory);\n    return (\n      <HStack justifyContent={\"space-between\"}>\n        <Text fontWeight={600}>Achieved</Text>\n        <Text>\n          {oneRepMax.weight} kg x {oneRepMax.reps}\n        </Text>\n      </HStack>\n    );\n  };\n\n  const renderEstimatedPR = () => {\n    const estimatedPR = getEstimatedOneRepMax(exerciseHistory);\n    return (\n      <HStack justifyContent={\"space-between\"}>\n        <Text fontWeight={600}>Estimate 1 RM</Text>\n        <Text>{estimatedPR} kg</Text>\n      </HStack>\n    );\n  };\n\n  const renderTotalVolume = () => {\n    const bestTotalVole = getBestVolume(exerciseHistory);\n    return (\n      <HStack justifyContent={\"space-between\"}>\n        <Text fontWeight={600}>Best Volume</Text>\n        <Text>{bestTotalVole} kg</Text>\n      </HStack>\n    );\n  };\n\n  const renderBestPerformances = () => {\n    const bestPerformances = getBestPerformance(exerciseHistory);\n\n    return (\n      <VStack my={2}>\n        <HStack justifyContent={\"space-between\"}>\n          <Text textAlign={\"center\"} fontWeight={600}>\n            Reps\n          </Text>\n          <Text textAlign={\"center\"} fontWeight={600}>\n            Set Performance\n          </Text>\n          <Text textAlign={\"center\"} fontWeight={600}>\n            1RM\n          </Text>\n        </HStack>\n        <VStack space={1}>\n          {bestPerformances.map((performance, index) => {\n            if (performance.reps === 0 || performance.weight === 0) return null;\n            return (\n              <HStack justifyContent={\"space-between\"} key={index}>\n                <Text textAlign={\"center\"}>{(index += 1)}</Text>\n                <Text\n                  textAlign={\"center\"}\n                >{`${performance.weight} kg x ${performance.reps}`}</Text>\n                <Text textAlign={\"center\"}>\n                  {calculateOneRepMax([\n                    {\n                      weight: String(performance.weight),\n                      reps: String(performance.reps),\n                    },\n                  ])}{\" \"}\n                  kg\n                </Text>\n              </HStack>\n            );\n          })}\n        </VStack>\n      </VStack>\n    );\n  };\n\n  return (\n    <VStack space={2}>\n      <Text\n        textTransform={\"uppercase\"}\n        letterSpacing={\"lg\"}\n        fontWeight={\"light\"}\n        fontSize=\"xs\"\n        my={2}\n      >\n        Personal Records\n      </Text>\n      {renderAchievedPR()}\n      {renderEstimatedPR()}\n      {renderTotalVolume()}\n      {renderBestPerformances()}\n    </VStack>\n  );\n};\n\nexport default ExerciseDetailsRecords;\n","import { IExerciseHistory } from \"../../hooks/useExerciseHistory\";\nimport calculateOneRepMax from \"./calculateOneRepMax\";\n\nexport const getEstimatedOneRepMax = (history: IExerciseHistory) => {\n  const oneRepMaxes = Object.values(history).map((lift) => {\n    const { sets } = lift;\n\n    if (!sets.length) return [0];\n    return calculateOneRepMax(sets);\n  });\n\n  const oneRepMaxArr = oneRepMaxes.map((el) => Math.max(...el));\n\n  return Math.max(...oneRepMaxArr);\n};\n\nexport const getAcheivedOneRepMax = (history: IExerciseHistory) => {\n  const sets = Object.values(history)\n    .map((lift) => lift.sets)\n    .flat(1);\n\n  const bestSet = sets.reduce(\n    (acc, set) => {\n      if (!set) return acc;\n      const weight = parseInt(set.weight);\n      const reps = parseInt(set.reps);\n      if (reps >= 1 && weight > acc.weight) return { weight, reps };\n      return acc;\n    },\n    { weight: 0, reps: 0 }\n  );\n\n  return bestSet;\n};\n\nexport const getBestVolume = (history: IExerciseHistory) => {\n  const sets = Object.values(history)\n    .map((lift) => lift.sets)\n    .flat(2);\n\n  const volume = sets.reduce((acc, set) => {\n    if (!set) return acc;\n    const weight = parseInt(set.weight);\n    const reps = parseInt(set.reps);\n    const volume = weight * reps;\n    return volume > acc ? volume : acc;\n  }, 0);\n\n  return volume;\n};\n\nexport const getBestPerformance = (history: IExerciseHistory) => {\n\n  interface set {\n    weight: number;\n    reps: number;\n    setNumber: number;\n  }\n\n  let bestPerformance: set[] = []\n  const repsArr = Array.from({ length: 10 }, (_, i) => i + 1);\n\n  const sets = Object.values(history)\n    .map((lift) => lift.sets)\n    .flat(1);\n\n  repsArr.forEach((reps, i) => {\n    const newSets = sets.filter((set) => set.reps === reps.toString());\n    const reducedSets = newSets.reduce(\n      (acc, set) => {\n        if (!set) return acc;\n\n        const weight = parseInt(set.weight);\n        const reps = parseInt(set.reps);\n\n        if (weight > acc.weight)\n          return { weight, reps, setNumber: set.setNumber };\n        return acc;\n      },\n      { weight: 0, reps: 0, setNumber: 0 }\n    );\n\n    bestPerformance.push(reducedSets)\n  });\n\n  return bestPerformance;\n};\n"],"sourceRoot":""}